<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Data Validator (Full Bridge Version)</title>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        /* Base Styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f1f5f9;
            color: #0f172a;
        }

        .font-mono {
            font-family: 'JetBrains Mono', monospace;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #e2e8f0;
        }

        ::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .animate-fade-in {
            animation: fadeIn 0.4s ease-out forwards;
        }

        .toast-enter {
            animation: slideInRight 0.3s ease-out forwards;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback, useRef } = React;

        // ==========================================
        // 1. SYSTEM CONFIGURATION & CONSTANTS
        // ==========================================

        // API Configuration (Bridge Mode)
        const apiKey = ""; // System injected by Canvas environment
        const MODEL_ID = "gemini-2.5-flash-preview-09-2025";

        // Business Logic Constants
        const UPDATE_DATE_COL = "Update Date";
        // Updated: Exclude A:D (Brand Logo, Image, Blade Range, Total) AND U (Price Range)
        const HIDDEN_COLS = ["Brand Logo", "Image", "Blade Range", "Total", "Price Range"];
        const CHUNK_SIZE = 10;
        const MAX_RETRIES = 5;
        const BASE_DELAY_MS = 2000; // Increased base delay for stability

        // External Resource URLs
        const PROMPT_URLS = {
            "Miter Saw Validator": "https://raw.githubusercontent.com/eeee821022/Storage/main/share/%E7%B6%B2%E9%A0%81_PT%E8%B3%87%E6%96%99%E5%BA%AB/miterSaw_Prompt.js",
            "Table Saw Validator": "https://raw.githubusercontent.com/eeee821022/Storage/main/share/%E7%B6%B2%E9%A0%81_PT%E8%B3%87%E6%96%99%E5%BA%AB/tableSaw_Prompt.js"
        };

        // Initialize Global Registry
        window.PROMPT_REGISTRY = window.PROMPT_REGISTRY || {};

        // ==========================================
        // 2. HELPER FUNCTIONS & UTILITIES
        // ==========================================

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // Data Cleaning: Prevents Excel/Sheets column shift issues
        const sanitizeForExport = (val) => {
            if (val === null || val === undefined) return "";
            return String(val).replace(/[\n\r\t]/g, " ").trim();
        };

        // Column Header Parsing for Lock Cols (e.g., "A" -> Index 0)
        const parseColumnString = (colStr, headers) => {
            if (!colStr) return [];
            return colStr.split(',')
                .map(s => s.trim().toUpperCase())
                .map(val => {
                    if (/^[A-Z]+$/.test(val)) {
                        let idx = 0;
                        for (let i = 0; i < val.length; i++) {
                            idx = idx * 26 + (val.charCodeAt(i) - 64);
                        }
                        return headers[idx - 1];
                    }
                    return val; // Assume it's a header name if not A-Z
                })
                .filter(h => h && headers.includes(h));
        };

        // ==========================================
        // 3. CORE LOGIC: VOTING MECHANISM
        // ==========================================

        /**
         * mergeByVoting
         * Implements the 4-Round Voting Logic described in the manual.
         */
        const mergeByVoting = (originalRow, r1Row, r2Row, r3Row, r4Row, lockedCols, allHeaders) => {
            const result = { ...originalRow };

            // Filter columns that need voting (exclude system cols and hidden cols)
            const votableFields = allHeaders.filter(h =>
                h !== UPDATE_DATE_COL &&
                !HIDDEN_COLS.includes(h) &&
                h !== 'Image URL' &&
                !lockedCols.includes(h)
            );

            votableFields.forEach(field => {
                const origVal = String(originalRow[field] || "").trim();
                const votes = {};

                // 1. Cast Votes
                // Original gets 2 votes
                if (origVal !== "") {
                    votes[origVal] = (votes[origVal] || 0) + 2;
                }

                // AI Rounds get 1 vote each
                // Handle potentially null/undefined rows from failed rounds
                [r1Row, r2Row, r3Row, r4Row].forEach(row => {
                    if (!row) return; // Skip failed rounds
                    const val = String(row[field] || "").trim();
                    if (val !== "") {
                        votes[val] = (votes[val] || 0) + 1;
                    }
                });

                // 2. Determine Winner
                const candidates = Object.entries(votes).sort((a, b) => b[1] - a[1]);

                if (candidates.length > 0) {
                    const [winnerVal, winnerVotes] = candidates[0];

                    if (origVal === "") {
                        // Scenario 2: Original is empty. Need consensus (>= 2 votes) to fill.
                        if (winnerVotes >= 2) {
                            result[field] = winnerVal;
                        } else {
                            result[field] = "";
                        }
                    } else {
                        // Scenario 1: Original exists.
                        // Tie-breaker: If Original has same votes as Winner, Original wins.
                        if (votes[origVal] === winnerVotes) {
                            result[field] = origVal;
                        } else {
                            result[field] = winnerVal;
                        }
                    }
                }
            });

            // Re-apply Locked Columns explicitly
            lockedCols.forEach(col => {
                if (originalRow[col] !== undefined) {
                    result[col] = originalRow[col];
                }
            });

            return result;
        };

        // ==========================================
        // 4. API SERVICES
        // ==========================================

        const GAS_Service = {
            fetchSheetNames: async (scriptUrl) => {
                const res = await fetch(`${scriptUrl}?action=getSheets`, { redirect: 'follow' });
                const data = await res.json();
                if (!Array.isArray(data)) throw new Error("Invalid sheet list format");
                return data;
            },
            fetchSheetData: async (scriptUrl, sheetName) => {
                const url = `${scriptUrl}?action=getData&sheet=${encodeURIComponent(sheetName)}`;
                const res = await fetch(url, { redirect: 'follow' });
                const data = await res.json();
                if (!Array.isArray(data)) throw new Error("Invalid data format");
                return data;
            }
        };

        // Gemini API Service
        const Gemini_Service = {
            callAPI: async (dataChunk, prompt, useGoogleSearch) => {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_ID}:generateContent?key=${apiKey}`;

                // Optimized System Instruction - VERY STRICT
                const systemInstruction = `*** SYSTEM COMMAND ***
You are a pure JSON generator. 
1. Output ONLY valid JSON.
2. NO conversational text. NO introductions. NO explanations. NO bullet points.
3. START your response with '{' and END with '}'.
4. Do NOT use Markdown formatting (no \`\`\`json).
5. If you cannot verify data, return null or empty string in fields, but maintain JSON structure.`;

                // Recursive Execute Function with Dynamic Prompt Injection
                const execute = async (retryCount = 0) => {
                    try {
                        let finalPrompt = `${prompt}\n\n${systemInstruction}\n\nTarget Data JSON:\n${JSON.stringify(dataChunk)}`;

                        // INJECT WARNING ON RETRY
                        if (retryCount > 0) {
                            finalPrompt += `\n\n\n!!! IMPORTANT WARNING (RETRY ${retryCount}) !!!\nYour previous response was REJECTED because it was text, not JSON.\nDO NOT use bullet points.\nDO NOT summarize.\nOUTPUT ONLY RAW JSON.\nStart immediately with '{' or '['.`;
                        }

                        const payload = {
                            contents: [{
                                parts: [{ text: finalPrompt }]
                            }]
                        };

                        if (useGoogleSearch) {
                            payload.tools = [{ "google_search": {} }];
                        }

                        const response = await fetch(url, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            if (response.status === 429) throw new Error("Rate Limit Exceeded");
                            throw new Error(`HTTP Error ${response.status}`);
                        }

                        const resJson = await response.json();
                        const candidate = resJson.candidates?.[0];
                        if (!candidate) throw new Error("Empty Candidate Response");

                        const text = candidate.content?.parts?.[0]?.text;
                        if (!text) throw new Error("Empty Text Content");

                        // --- Robust JSON Extraction & Repair Logic ---
                        let jsonStr = text.trim();

                        // 1. Find the widest possible JSON container (Object {} or Array [])
                        // We search for the first occurrence of { or [ and the last occurrence of } or ]
                        const firstOpen = jsonStr.search(/[\{\[]/);
                        const lastClose = Math.max(jsonStr.lastIndexOf('}'), jsonStr.lastIndexOf(']'));

                        if (firstOpen === -1 || lastClose === -1) {
                            console.warn("No JSON structure found in response (Text Mode Detected):", text.substring(0, 100) + "...");
                            throw new Error("No JSON Structure Found (Conversational Override)");
                        }

                        if (firstOpen !== -1 && lastClose !== -1) {
                            jsonStr = jsonStr.substring(firstOpen, lastClose + 1);
                        }

                        let parsedData;
                        try {
                            parsedData = JSON.parse(jsonStr);
                        } catch (parseError) {
                            // Recovery Strategies
                            let recovered = false;

                            // Strategy A: Double Closing Braces/Trailing Garbage (e.g. }} or } } or ]])
                            if (!recovered) {
                                let tempStr = jsonStr;
                                // Try trimming up to 3 trailing characters (brackets or spaces)
                                for (let i = 0; i < 3; i++) {
                                    if (tempStr.endsWith('}') || tempStr.endsWith(']')) {
                                        tempStr = tempStr.substring(0, tempStr.length - 1).trim();
                                        try {
                                            parsedData = JSON.parse(tempStr);
                                            recovered = true;
                                            console.warn("JSON Repaired by trimming trailing characters");
                                            break;
                                        } catch (e) { continue; }
                                    } else {
                                        break;
                                    }
                                }
                            }

                            // Strategy B: Missing Header (Starts with [ ends with })
                            if (!recovered && jsonStr.startsWith('[') && jsonStr.endsWith('}')) {
                                try {
                                    parsedData = JSON.parse(`{ "corrected": ${jsonStr}`);
                                    recovered = true;
                                    console.warn("JSON Repaired by adding missing header");
                                } catch (e) { }
                            }

                            if (!recovered) {
                                console.error("JSON Parse Failed, Raw:", text);
                                throw new Error("Invalid JSON Output from AI");
                            }
                        }

                        const groundingMetadata = candidate.groundingMetadata?.groundingAttributions?.map(a => ({
                            uri: a.web?.uri,
                            title: a.web?.title
                        })) || [];

                        return { data: parsedData, grounding: groundingMetadata, raw: resJson };

                    } catch (error) {
                        if (retryCount < MAX_RETRIES) {
                            // Exponential Backoff: 2s, 4s, 8s, 16s...
                            const delay = Math.pow(2, retryCount) * BASE_DELAY_MS;
                            console.warn(`Retry ${retryCount + 1}/${MAX_RETRIES} after ${delay}ms... Reason: ${error.message}`);
                            await sleep(delay);
                            return execute(retryCount + 1);
                        }
                        throw error;
                    }
                };

                return execute();
            }
        };

        // ==========================================
        // 5. MAIN REACT COMPONENT
        // ==========================================

        const App = () => {
            const [scriptUrl, setScriptUrl] = useState(localStorage.getItem('AI_VALIDATOR_URL') || '');
            const [isConnected, setIsConnected] = useState(false);
            const [isConnecting, setIsConnecting] = useState(false);
            const [sheetNames, setSheetNames] = useState([]);
            const [selectedSheet, setSelectedSheet] = useState("");
            const [selectedCountry, setSelectedCountry] = useState("USA");
            const [rawRows, setRawRows] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [progress, setProgress] = useState({ percent: 0, status: "" });
            const [processedBatches, setProcessedBatches] = useState([]);
            // Updated: Default Lock Column E (Image URL)
            const [excludedColumns, setExcludedColumns] = useState("E");
            const [selectedPromptKey, setSelectedPromptKey] = useState("Miter Saw Validator");
            const [toast, setToast] = useState(null);
            const [logHistory, setLogHistory] = useState([]);
            const [logViewer, setLogViewer] = useState({ isOpen: false, type: 'prompt', index: 0 });
            // New: PT Data State
            const [ptData, setPtData] = useState([]);
            const [ignoreNewItems, setIgnoreNewItems] = useState(true);
            const [ptImportedModels, setPtImportedModels] = useState(new Set());
            const [ptOnlyMode, setPtOnlyMode] = useState(true);

            useEffect(() => {
                const loadPrompt = async () => {
                    const url = PROMPT_URLS[selectedPromptKey];
                    if (url) {
                        try {
                            const res = await fetch(url);
                            if (res.ok) {
                                const text = await res.text();
                                new Function(text)();
                                console.log(`Prompt loaded: ${selectedPromptKey}`);
                            }
                        } catch (e) {
                            console.error("Failed to load prompt config", e);
                        }
                    }
                };
                loadPrompt();
            }, [selectedPromptKey]);

            const showToast = (message, type = 'success') => {
                setToast({ message, type });
                setTimeout(() => setToast(null), 4000);
            };

            const fullHeadersOrder = useMemo(() => {
                if (rawRows.length === 0) return [];
                const keys = Object.keys(rawRows[0]);
                const fixedOrder = [...HIDDEN_COLS, UPDATE_DATE_COL];
                const rest = keys.filter(k => !fixedOrder.some(fo => fo.toLowerCase() === k.toLowerCase()));
                return [...fixedOrder, ...rest];
            }, [rawRows]);

            const displayHeaders = useMemo(() => fullHeadersOrder.filter(h => !HIDDEN_COLS.includes(h)), [fullHeadersOrder]);

            const handleConnect = async () => {
                if (!scriptUrl) return showToast("Please enter Script URL", "error");
                setIsConnecting(true);
                try {
                    const sheets = await GAS_Service.fetchSheetNames(scriptUrl);
                    setSheetNames(sheets);
                    setIsConnected(true);
                    localStorage.setItem('AI_VALIDATOR_URL', scriptUrl);
                    showToast("Connected to Google Sheets");
                } catch (e) {
                    showToast(e.message, "error");
                } finally {
                    setIsConnecting(false);
                }
            };

            const handleLoadSheet = async (sheet) => {
                setSelectedSheet(sheet);
                try {
                    const data = await GAS_Service.fetchSheetData(scriptUrl, sheet);
                    const cleaned = data.filter(r => (r['Model #'] || r['Brand'])).map(row => {
                        const newRow = {};
                        Object.keys(row).forEach(k => {
                            const cleanK = k.replace(/[\n\r]/g, " ").trim();
                            if (!cleanK.startsWith('_')) newRow[cleanK] = row[k];
                        });
                        newRow[UPDATE_DATE_COL] = newRow[UPDATE_DATE_COL] || newRow["更新日期"] || "";
                        delete newRow["更新日期"];
                        return newRow;
                    });
                    setRawRows(cleaned);
                    setProcessedBatches([]);
                    showToast(`Loaded ${cleaned.length} rows`);
                } catch (e) {
                    showToast(e.message, "error");
                }
            };

            // --- PT Data Load Logic ---

            const handleLoadPTData = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const text = e.target.result;
                        const rows = parseCSV(text);
                        setPtData(rows);

                        if (rawRows.length > 0) {
                            applyPTDataToRaw(rows, rawRows);
                        } else {
                            showToast(`Loaded ${rows.length} rows from CSV. Please load Sheet data to apply.`, "success");
                        }
                    } catch (err) {
                        console.error(err);
                        showToast("Failed to parse CSV: " + err.message, "error");
                    }
                };
                reader.readAsText(file, 'utf-8');
            };

            const parseCSV = (text) => {
                const lines = text.split(/\r?\n/);
                // Handle basic CSV parsing (assuming standard format from pandas)
                // Using a simple split might break on commas inside quotes.
                // A slightly more robust regex approach:
                const parseLine = (line) => {
                    const pattern = /(".*?"|[^",\s]+)(?=\s*,|\s*$)/g; // Simplified
                    // Better regex for CSV:
                    const matches = [];
                    let match;
                    const regex = /(?:^|,)(?:"([^"]*(?:""[^"]*)*)"|([^",]*))/g;
                    while ((match = regex.exec(line)) !== null) {
                        // match[1] is quoted value, match[2] is unquoted
                        let val = match[1] ? match[1].replace(/""/g, '"') : match[2];
                        matches.push(val ? val.trim() : "");
                        if (regex.lastIndex === line.length) break; // End of line
                    }
                    // Handle trailing empty field if comma is last char
                    if (line.endsWith(',')) matches.push("");
                    return matches.slice(0, -1); // Remove the extra empty match from the loop structure if needed, or adjust regex
                };

                // Fallback to simple split if complex parsing unnecessary or risky without library
                // The pandas to_csv usually quotes fields. 
                // Let's use a standard simple parser logic.
                const headers = lines[0].split(',').map(h => h.trim());

                return lines.slice(1).filter(l => l.trim()).map(line => {
                    // Simple split for now, assuming no commas in fields for simplicity 
                    // or fairly standard CSV. 
                    // If commas in fields are common, we need the regex. 
                    // Let's try the simple split first as it is safer than a buggy regex.
                    // If the user's CSV is complex, we might need a library. 
                    // But usually these are product catalogs.
                    // Actually, titles often have commas. We MUST handle quotes.

                    const row = {};
                    let currentVal = '';
                    let inQuotes = false;
                    let values = [];

                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        if (char === '"') {
                            if (inQuotes && line[i + 1] === '"') {
                                currentVal += '"';
                                i++;
                            } else {
                                inQuotes = !inQuotes;
                            }
                        } else if (char === ',' && !inQuotes) {
                            values.push(currentVal);
                            currentVal = '';
                        } else {
                            currentVal += char;
                        }
                    }
                    values.push(currentVal);

                    headers.forEach((h, i) => row[h] = values[i] ? values[i].trim() : '');
                    return row;
                });
            };

            const applyPTDataToRaw = (ptRows, currentRawRows) => {
                // 1. Index PT Data
                // Group by SKU for filling missing metadata
                const ptBySKU = {};
                // Group by Model for finding prices
                const ptByModel = {};

                // Identify date headers in PT CSV (YYYYMMDD)
                const dateHeaders = [];
                if (ptRows.length > 0) {
                    Object.keys(ptRows[0]).forEach(k => {
                        if (/^\d{8}$/.test(k)) dateHeaders.push(k);
                    });
                    dateHeaders.sort().reverse(); // Newest first
                }

                ptRows.forEach(row => {
                    const sku = row['SKU'];
                    const model = row['Model #'];
                    const exclude = row['Exclude Update'];

                    if (sku) ptBySKU[sku] = row;

                    if (model && exclude !== 'Y') {
                        if (!ptByModel[model]) ptByModel[model] = [];
                        ptByModel[model].push(row);
                    }
                });

                const today = new Date().toISOString().split('T')[0];
                let matchedCount = 0;

                const updated = currentRawRows.map(row => {
                    const newRow = { ...row };

                    // A. Fill Matching Metadata (via SKU)
                    const sku = newRow['SKU'] || newRow['Model #'] || ''; // Fallback for matching
                    // Note: Raw data might have SKU in 'SKU' col or 'Model #' col depending on sheet
                    // Let's try to match strict SKU first

                    let ptRowViaSku = ptBySKU[sku];
                    if (ptRowViaSku) {
                        if (!newRow['Model #'] && ptRowViaSku['Model #']) {
                            newRow['Model #'] = ptRowViaSku['Model #'];
                            // Mark as new item if we filled critical info
                            newRow[UPDATE_DATE_COL] = `${today} New Item`;
                        }
                        if (!newRow['Brand'] && ptRowViaSku['Brand']) {
                            newRow['Brand'] = ptRowViaSku['Brand'];
                        }
                    }

                    // B. Update Price & Image (via Model)
                    const model = newRow['Model #'];
                    if (model && ptByModel[model]) {
                        const group = ptByModel[model];

                        let bestPrice = null;
                        let bestRow = null;

                        // Find most recent date that has prices
                        for (const dateCol of dateHeaders) {
                            let minP = Infinity;
                            let minRow = null;

                            group.forEach(pRow => {
                                const pValStr = pRow[dateCol];
                                if (pValStr) {
                                    // Parse price (remove currency, comma vs dot?)
                                    // Assume format: "1234.56" or "1234"
                                    const pNum = parseFloat(pValStr.replace(/[^\d.]/g, ''));
                                    if (!isNaN(pNum) && pNum > 0) {
                                        if (pNum < minP) {
                                            minP = pNum;
                                            minRow = pRow;
                                        }
                                    }
                                }
                            });

                            if (minRow) {
                                bestPrice = minP;
                                bestRow = minRow;
                                break; // Found latest date with data
                            }
                        }

                        if (bestRow) {
                            // Update Price (Col T - "Price")
                            newRow['Price'] = bestPrice;

                            // Update Image URL (Grab from the row with best price)
                            if (bestRow['Image URL']) {
                                // Try to find standard Image headers
                                if (newRow.hasOwnProperty('Image URL')) newRow['Image URL'] = bestRow['Image URL'];
                                else if (newRow.hasOwnProperty('Image')) newRow['Image'] = bestRow['Image URL'];
                                else newRow['Image URL'] = bestRow['Image URL']; // Default create
                            }

                            // Mark as updated if not already marked as New Item
                            if (!newRow[UPDATE_DATE_COL] || !newRow[UPDATE_DATE_COL].includes('New Item')) {
                                newRow[UPDATE_DATE_COL] = `${today} Price Updated`;
                            }
                            matchedCount++;
                        }
                    }

                    return newRow;
                });

                // C. NEW: 找出 CSV 中有但 GS 中沒有的機型並新增
                const existingModels = new Set(
                    currentRawRows.map(r => (r['Model #'] || '').trim().toLowerCase())
                        .filter(m => m)
                );

                console.log('=== DEBUG: New Model Detection ===');
                console.log('Existing models in GS:', existingModels.size);
                console.log('Unique models in PT CSV:', Object.keys(ptByModel).length);
                console.log('Date headers found:', dateHeaders);

                const newRows = [];
                const allHeaders = Object.keys(currentRawRows[0] || {});
                console.log('Headers from GS:', allHeaders);

                Object.entries(ptByModel).forEach(([model, ptRowGroup]) => {
                    const modelLower = model.toLowerCase();
                    if (!existingModels.has(modelLower)) {
                        // 這是新機型，需要新增到表格
                        console.log('NEW model found:', model);
                        const representative = ptRowGroup[0]; // 取第一筆作為代表

                        // 找最新的價格
                        let bestPrice = null;
                        for (const dateCol of dateHeaders) {
                            for (const pRow of ptRowGroup) {
                                const pValStr = pRow[dateCol];
                                if (pValStr) {
                                    const pNum = parseFloat(pValStr.replace(/[^\d.]/g, ''));
                                    if (!isNaN(pNum) && pNum > 0) {
                                        if (bestPrice === null || pNum < bestPrice) {
                                            bestPrice = pNum;
                                        }
                                    }
                                }
                            }
                            if (bestPrice !== null) break;
                        }

                        // 建立新行
                        const newRow = {};
                        allHeaders.forEach(h => newRow[h] = ''); // 初始化所有欄位

                        newRow['Model #'] = model;
                        newRow['Brand'] = representative['Brand'] || '';
                        newRow['Image URL'] = representative['Image URL'] || '';
                        newRow['Price'] = bestPrice || '';
                        newRow[UPDATE_DATE_COL] = `${today} NEW`;

                        newRows.push(newRow);
                    }
                });

                console.log('Total NEW rows to add:', newRows.length);

                // Track only NEW models from PT (not updated ones)
                const importedModels = new Set();
                newRows.forEach(row => {
                    const model = row['Model #'] || '';
                    if (model) importedModels.add(model.toLowerCase());
                });
                setPtImportedModels(importedModels);
                console.log('PT NEW Models:', importedModels.size);

                const finalRows = [...updated, ...newRows];
                setRawRows(finalRows);
                showToast(`Applied PT Data: Updated ${matchedCount} items, Added ${newRows.length} NEW models. Check '${UPDATE_DATE_COL}' column.`, newRows.length > 0 ? 'success' : 'info');
            };

            const startAudit = async () => {
                if (isProcessing || rawRows.length === 0) return;

                let rowsToProcess = rawRows;

                // Check if PT-only mode is enabled
                if (ptOnlyMode) {
                    if (ptImportedModels.size === 0) {
                        showToast('請先載入 PT CSV 資料 (Load PT CSV first)', 'error');
                        return;
                    }

                    // Filter to only PT-imported models
                    rowsToProcess = rawRows.filter(row => {
                        const model = (row['Model #'] || '').toLowerCase();
                        return ptImportedModels.has(model);
                    });

                    if (rowsToProcess.length === 0) {
                        showToast('沒有找到 PT 匯入的機型 (No PT-imported models found)', 'error');
                        return;
                    }
                }

                console.log(`Processing ${rowsToProcess.length} models${ptOnlyMode ? ' (PT-only mode)' : ''} out of ${rawRows.length} total`);

                setIsProcessing(true);
                setProcessedBatches([]);
                setLogHistory([]);
                setProgress({ percent: 0, status: "Initializing..." });

                const startTime = Date.now();
                const today = new Date().toISOString().split('T')[0];

                try {
                    const groups = {};
                    rowsToProcess.forEach(row => {
                        const brand = String(row['Brand'] || 'Unknown').trim();
                        const key = brand.toLowerCase();
                        if (!groups[key]) groups[key] = { name: brand, rows: [] };
                        groups[key].rows.push(row);
                    });

                    const brandKeys = Object.keys(groups);
                    const lockedCols = parseColumnString(excludedColumns, fullHeadersOrder);

                    let totalChunks = 0;
                    brandKeys.forEach(k => totalChunks += Math.ceil(groups[k].rows.length / CHUNK_SIZE));
                    let processedChunks = 0;

                    for (const key of brandKeys) {
                        const brandGroup = groups[key];
                        const brandName = brandGroup.name;

                        const config = window.PROMPT_REGISTRY?.[selectedPromptKey];
                        const tplSearch = config?.systemPromptTemplate || ((t, c) => `Verify ${t} in ${c} with Google Search.`);
                        const tplNoSearch = config?.systemPromptTemplateNoSearch || ((t, c) => `Verify ${t} in ${c} with Internal Knowledge.`);

                        const promptSearch = tplSearch(selectedSheet, selectedCountry).replace(/{{BRAND}}/g, brandName);
                        const promptNoSearch = tplNoSearch(selectedSheet, selectedCountry).replace(/{{BRAND}}/g, brandName);

                        for (let i = 0; i < brandGroup.rows.length; i += CHUNK_SIZE) {
                            processedChunks++;
                            const chunk = brandGroup.rows.slice(i, i + CHUNK_SIZE);

                            // Prepare chunk for AI - Filter out HIDDEN_COLS
                            const chunkForAI = chunk.map(row => {
                                const cleanRow = { ...row };
                                HIDDEN_COLS.forEach(h => delete cleanRow[h]);
                                return cleanRow;
                            });

                            setProgress({
                                percent: Math.round((processedChunks / totalChunks) * 100),
                                status: `${brandName} [${Math.ceil((i + 1) / CHUNK_SIZE)}/${Math.ceil(brandGroup.rows.length / CHUNK_SIZE)}] - 4-Round Voting...`
                            });

                            if (processedChunks > 1) await sleep(BASE_DELAY_MS);

                            // Safe Call Wrapper to prevent one round failure from killing the batch
                            const safeCall = async (chunk, prompt, search) => {
                                try {
                                    return await Gemini_Service.callAPI(chunk, prompt, search);
                                } catch (e) {
                                    console.error("Round failed after retries (skipping):", e);
                                    // Return empty structure so voting continues with partial data
                                    return { data: { corrected: [], new_items: [] }, grounding: [] };
                                }
                            };

                            const [r1, r2, r3, r4] = await Promise.all([
                                safeCall(chunkForAI, promptSearch, true),
                                safeCall(chunkForAI, promptSearch, true),
                                safeCall(chunkForAI, promptNoSearch, false),
                                safeCall(chunkForAI, promptNoSearch, false)
                            ]);

                            const timestamp = new Date().toLocaleTimeString();
                            [r1, r2, r3, r4].forEach((res, idx) => {
                                setLogHistory(prev => [{
                                    id: Date.now() + idx,
                                    timestamp,
                                    brand: `${brandName} (Batch ${Math.ceil((i + 1) / CHUNK_SIZE)})`,
                                    round: `R${idx + 1} [${idx < 2 ? 'Google' : 'Model'}]`,
                                    prompt: idx < 2 ? promptSearch : promptNoSearch,
                                    response: res.data || "FAILED",
                                    raw: res.raw
                                }, ...prev]);
                            });

                            // Safe list extraction
                            const getList = (r) => (r && r.data) ? (Array.isArray(r.data) ? r.data : (r.data.corrected || [])) : [];
                            const l1 = getList(r1), l2 = getList(r2), l3 = getList(r3), l4 = getList(r4);

                            const corrected = chunk.map((orig, idx) => {
                                const merged = mergeByVoting(
                                    orig,
                                    l1[idx], l2[idx], l3[idx], l4[idx],
                                    lockedCols,
                                    displayHeaders
                                );
                                const hasChanges = displayHeaders.some(h =>
                                    h !== UPDATE_DATE_COL &&
                                    String(merged[h] || "").trim() !== String(orig[h] || "").trim()
                                );
                                merged[UPDATE_DATE_COL] = hasChanges ? `${today} Corrected` : `${today} Confirmed`;
                                return merged;
                            });

                            // Only take new items from valid results (unless ignoreNewItems is checked)
                            let newItemsRaw = [];
                            if (!ignoreNewItems && r1 && r1.data) newItemsRaw = Array.isArray(r1.data) ? [] : (r1.data.new_items || []);

                            const newItems = newItemsRaw.map(item => {
                                item[UPDATE_DATE_COL] = `${today} New Item`;
                                return item;
                            });

                            setProcessedBatches(prev => [...prev, {
                                brand: brandName,
                                original: chunk,
                                corrected: corrected,
                                newItems: newItems,
                                grounding: r1.grounding
                            }]);
                        }
                    }

                    setProgress({ percent: 100, status: "Completed" });
                    showToast(`Audit Completed in ${((Date.now() - startTime) / 1000).toFixed(1)}s`);

                } catch (error) {
                    console.error(error);
                    showToast(`Processing Failed: ${error.message}`, "error");
                    setProgress({ percent: 0, status: "Error: " + error.message });
                } finally {
                    setIsProcessing(false);
                }
            };

            const handleCopy = () => {
                // Merge AI results back into full rawRows
                let data = [...rawRows];
                if (processedBatches.length > 0) {
                    const correctedMap = new Map();
                    processedBatches.forEach(b => {
                        b.corrected.forEach(row => {
                            const model = row['Model #'] || '';
                            if (model) correctedMap.set(model.toLowerCase(), row);
                        });
                    });
                    // Update existing rows with AI corrections
                    data = rawRows.map(row => {
                        const model = (row['Model #'] || '').toLowerCase();
                        return correctedMap.get(model) || row;
                    });
                    // Add any new items from AI (if ignoreNewItems is false)
                    if (!ignoreNewItems) {
                        processedBatches.forEach(b => {
                            b.newItems.forEach(newRow => {
                                const model = (newRow['Model #'] || '').toLowerCase();
                                if (!data.some(r => (r['Model #'] || '').toLowerCase() === model)) {
                                    data.push(newRow);
                                }
                            });
                        });
                    }
                }
                if (data.length === 0) return showToast("No data to copy", "error");
                let tsv = displayHeaders.join('\t') + '\n';
                data.forEach(row => {
                    tsv += displayHeaders.map(h => sanitizeForExport(row[h])).join('\t') + '\n';
                });
                const ta = document.createElement('textarea');
                ta.value = tsv;
                document.body.appendChild(ta);
                ta.select();
                try { document.execCommand('copy'); showToast(`Copied ${data.length} rows to Clipboard`); }
                catch (e) { showToast("Copy failed", "error"); }
                document.body.removeChild(ta);
            };

            const handleDownloadCSV = () => {
                // Merge AI results back into full rawRows
                let data = [...rawRows];
                if (processedBatches.length > 0) {
                    const correctedMap = new Map();
                    processedBatches.forEach(b => {
                        b.corrected.forEach(row => {
                            const model = row['Model #'] || '';
                            if (model) correctedMap.set(model.toLowerCase(), row);
                        });
                    });
                    data = rawRows.map(row => {
                        const model = (row['Model #'] || '').toLowerCase();
                        return correctedMap.get(model) || row;
                    });
                    if (!ignoreNewItems) {
                        processedBatches.forEach(b => {
                            b.newItems.forEach(newRow => {
                                const model = (newRow['Model #'] || '').toLowerCase();
                                if (!data.some(r => (r['Model #'] || '').toLowerCase() === model)) {
                                    data.push(newRow);
                                }
                            });
                        });
                    }
                }
                if (data.length === 0) return;
                let csv = displayHeaders.map(h => `"${h}"`).join(',') + '\n';
                data.forEach(row => {
                    csv += displayHeaders.map(h => {
                        const val = sanitizeForExport(row[h]).replace(/"/g, '""');
                        return `"${val}"`;
                    }).join(',') + '\n';
                });
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `Audit_Result_${new Date().toISOString().slice(0, 10)}.csv`;
                a.click();
            };

            const handleDownloadLogs = (all = false) => {
                if (logHistory.length === 0) return showToast("No logs available", "error");
                let content = "";
                if (all) {
                    content = "=== AI DATA VALIDATOR FULL LOGS ===\n";
                    content += `Date: ${new Date().toLocaleString()}\n`;
                    content += `Total Entries: ${logHistory.length}\n\n`;
                    [...logHistory].reverse().forEach((log, i) => {
                        content += `[Record #${i + 1}] --------------------------------------------------\n`;
                        content += `Time: ${log.timestamp}\n`;
                        content += `Brand: ${log.brand}\n`;
                        content += `Round: ${log.round}\n\n`;
                        content += `--- PROMPT ---\n${log.prompt}\n\n`;
                        content += `--- RESPONSE ---\n${JSON.stringify(log.response, null, 2)}\n\n`;
                    });
                } else {
                    const log = logHistory[logViewer.index];
                    if (!log) return;
                    content = logViewer.type === 'prompt' ? log.prompt : JSON.stringify(log.response, null, 2);
                }
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = all ? "Full_Logs.txt" : `Log_${logViewer.type}_${Date.now()}.txt`;
                a.click();
            };

            return (
                <div className="min-h-screen pb-20">
                    {toast && (
                        <div className={`fixed top-5 left-1/2 transform -translate-x-1/2 z-50 px-6 py-3 rounded-full shadow-2xl font-bold text-white text-sm toast-enter flex items-center gap-2 ${toast.type === 'error' ? 'bg-red-500' : 'bg-emerald-600'}`}>
                            <span>{toast.type === 'error' ? '⚠️' : '✅'}</span>
                            {toast.message}
                        </div>
                    )}

                    {/* Header */}
                    <header className="bg-white border-b border-slate-200 sticky top-0 z-30 shadow-sm">
                        <div className="container mx-auto px-4 py-4 flex flex-col md:flex-row justify-between items-center gap-4">
                            <div className="flex items-center gap-3">
                                <div className="bg-blue-600 text-white p-2 rounded-lg font-black text-xl tracking-tighter">AI</div>
                                <div>
                                    <h1 className="text-xl font-bold text-slate-800 tracking-tight">Data Validator <span className="text-xs bg-slate-100 text-slate-500 px-2 py-0.5 rounded-full border border-slate-200">BRIDGE API</span></h1>
                                    <p className="text-[10px] text-slate-400 font-bold uppercase tracking-widest mt-0.5">Full Feature Version v3.5.2</p>
                                </div>
                            </div>

                            <div className="flex w-full md:w-auto gap-2">
                                <input
                                    type="text"
                                    value={scriptUrl}
                                    onChange={e => setScriptUrl(e.target.value)}
                                    placeholder="Paste GAS Script URL here..."
                                    className="flex-1 md:w-80 bg-slate-50 border border-slate-200 rounded-lg px-4 py-2 text-xs focus:ring-2 focus:ring-blue-500 outline-none transition-all font-mono text-slate-600"
                                />
                                <button
                                    onClick={handleConnect}
                                    disabled={isConnecting}
                                    className={`px-6 py-2 rounded-lg text-xs font-bold transition-all shadow-sm ${isConnected ? 'bg-emerald-50 text-emerald-600 border border-emerald-200' : 'bg-slate-800 text-white hover:bg-slate-900'}`}
                                >
                                    {isConnecting ? '...' : isConnected ? 'CONNECTED' : 'CONNECT'}
                                </button>
                            </div>
                        </div>
                    </header>

                    <div className="container mx-auto px-4 py-6 grid grid-cols-1 lg:grid-cols-12 gap-6">

                        {/* Sidebar: Controls */}
                        <aside className="lg:col-span-3 space-y-6">

                            {/* Panel 1: Data Source */}
                            <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-5 space-y-4 animate-fade-in">
                                <h3 className="text-xs font-black text-slate-400 uppercase tracking-widest border-b border-slate-100 pb-2">Data Source</h3>

                                <div className="space-y-1">
                                    <label className="text-[10px] font-bold text-slate-500 uppercase">Target Region</label>
                                    <div className="grid grid-cols-4 gap-1">
                                        {['USA', 'DEU', 'TW', 'JP'].map(c => (
                                            <button
                                                key={c}
                                                onClick={() => setSelectedCountry(c)}
                                                className={`py-2 text-xs font-bold rounded-lg transition-all ${selectedCountry === c ? 'bg-blue-600 text-white shadow-md' : 'bg-slate-50 text-slate-500 hover:bg-slate-100'}`}
                                            >
                                                {c}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                <div className="space-y-1">
                                    <label className="text-[10px] font-bold text-slate-500 uppercase">Select Sheet</label>
                                    <select
                                        value={selectedSheet}
                                        onChange={e => handleLoadSheet(e.target.value)}
                                        disabled={!isConnected}
                                        className="w-full bg-slate-50 border border-slate-200 text-slate-700 text-sm rounded-lg p-2.5 outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 font-medium"
                                    >
                                        <option value="">{isConnected ? "Select a sheet..." : "Connect first..."}</option>
                                        {sheetNames.map(n => <option key={n} value={n}>{n}</option>)}
                                    </select>
                                </div>
                            </div>

                            {/* Panel: PT Data Load */}
                            <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-5 space-y-4 animate-fade-in">
                                <h3 className="text-xs font-black text-slate-400 uppercase tracking-widest border-b border-slate-100 pb-2">PT Data Load</h3>
                                <div className="space-y-1">
                                    <label className="text-[10px] font-bold text-slate-500 uppercase">Upload CSV</label>
                                    <input
                                        type="file"
                                        accept=".csv"
                                        onChange={handleLoadPTData}
                                        className="w-full text-xs file:mr-2 file:py-2 file:px-4 file:rounded-lg file:border-0 file:bg-blue-50 file:text-blue-600 file:font-bold hover:file:bg-blue-100 cursor-pointer text-slate-500"
                                    />
                                    <p className="text-[9px] text-slate-400">Load PT Crawler CSV to fill missing info & prices.</p>
                                </div>
                                {ptData.length > 0 && (
                                    <div className="text-xs text-emerald-600 font-bold flex items-center gap-1">
                                        <span>✓</span> {ptData.length} rows loaded
                                    </div>
                                )}
                            </div>

                            {/* Panel 2: Config */}
                            <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-5 space-y-4 animate-fade-in" style={{ animationDelay: '0.1s' }}>
                                <h3 className="text-xs font-black text-slate-400 uppercase tracking-widest border-b border-slate-100 pb-2">Configuration</h3>

                                <div className="space-y-1">
                                    <label className="text-[10px] font-bold text-slate-500 uppercase">Prompt Preset</label>
                                    <select
                                        value={selectedPromptKey}
                                        onChange={e => setSelectedPromptKey(e.target.value)}
                                        className="w-full bg-emerald-50 border border-emerald-200 text-emerald-800 text-xs rounded-lg p-2 font-bold outline-none"
                                    >
                                        {Object.keys(PROMPT_URLS).map(k => <option key={k} value={k}>{k}</option>)}
                                    </select>
                                </div>

                                <div className="space-y-1">
                                    <label className="text-[10px] font-bold text-slate-500 uppercase">Locked Columns</label>
                                    <input
                                        type="text"
                                        value={excludedColumns}
                                        onChange={e => setExcludedColumns(e.target.value)}
                                        className="w-full bg-slate-50 border border-slate-200 text-slate-600 text-xs rounded-lg p-2 font-mono"
                                        placeholder="e.g. A,B,T"
                                    />
                                    <p className="text-[9px] text-slate-400">Values in these columns will NOT be changed by AI.</p>
                                </div>

                                <div className="flex items-center gap-2 pt-2 border-t border-slate-100">
                                    <input
                                        type="checkbox"
                                        id="ignoreNewItems"
                                        checked={ignoreNewItems}
                                        onChange={e => setIgnoreNewItems(e.target.checked)}
                                        className="w-4 h-4 text-blue-600 border-slate-300 rounded focus:ring-blue-500"
                                    />
                                    <label htmlFor="ignoreNewItems" className="text-xs text-slate-600 font-medium">
                                        不接受 AI 新增機型
                                    </label>
                                </div>
                                <div className="flex items-center gap-2">
                                    <input
                                        type="checkbox"
                                        id="ptOnlyMode"
                                        checked={ptOnlyMode}
                                        onChange={e => setPtOnlyMode(e.target.checked)}
                                        className="w-4 h-4 text-emerald-600 border-slate-300 rounded focus:ring-emerald-500"
                                    />
                                    <label htmlFor="ptOnlyMode" className="text-xs text-slate-600 font-medium">
                                        只驗證 PT 匯入機型 {ptImportedModels.size > 0 && <span className="text-emerald-600">({ptImportedModels.size})</span>}
                                    </label>
                                </div>
                            </div>

                            {/* Action Button */}
                            <button
                                onClick={startAudit}
                                disabled={isProcessing || !selectedSheet}
                                className={`w-full py-4 rounded-xl shadow-lg font-black text-sm tracking-wide transition-all transform hover:scale-[1.02] active:scale-[0.98] ${isProcessing
                                    ? 'bg-slate-100 text-slate-400 cursor-not-allowed'
                                    : 'bg-gradient-to-r from-blue-600 to-indigo-600 text-white hover:shadow-blue-200'
                                    }`}
                            >
                                {isProcessing ? (
                                    <div className="flex flex-col items-center gap-1">
                                        <div className="w-4 h-4 border-2 border-slate-300 border-t-blue-500 rounded-full animate-spin"></div>
                                        <span className="text-[10px] font-mono">{progress.status}</span>
                                    </div>
                                ) : (
                                    <span className="flex items-center justify-center gap-2">
                                        <span>START AUDIT PROCESS</span>
                                        <span>➔</span>
                                    </span>
                                )}
                            </button>
                        </aside>

                        {/* Main Content: Table & Logs */}
                        <main className="lg:col-span-9 space-y-6">

                            {/* Toolbar */}
                            <div className="bg-white rounded-xl p-2 border border-slate-200 shadow-sm flex flex-wrap gap-2 items-center justify-between">
                                <div className="flex gap-2">
                                    <button onClick={() => setLogViewer(p => ({ ...p, isOpen: !p.isOpen }))} className="px-4 py-2 bg-slate-100 hover:bg-slate-200 text-slate-600 rounded-lg text-xs font-bold transition-colors">
                                        {logViewer.isOpen ? 'Hide Logs' : 'Show Logs'}
                                    </button>
                                    <div className="h-8 w-px bg-slate-200 mx-1"></div>
                                    <button onClick={() => handleDownloadLogs(false)} disabled={logHistory.length === 0} className="px-4 py-2 bg-amber-50 text-amber-600 border border-amber-100 hover:bg-amber-100 rounded-lg text-xs font-bold transition-colors disabled:opacity-50">
                                        DL Current Log
                                    </button>
                                    <button onClick={() => handleDownloadLogs(true)} disabled={logHistory.length === 0} className="px-4 py-2 bg-orange-50 text-orange-600 border border-orange-100 hover:bg-orange-100 rounded-lg text-xs font-bold transition-colors disabled:opacity-50">
                                        DL All Logs
                                    </button>
                                </div>

                                <div className="flex gap-2">
                                    <button onClick={handleDownloadCSV} disabled={processedBatches.length === 0} className="px-4 py-2 bg-purple-50 text-purple-600 border border-purple-100 hover:bg-purple-100 rounded-lg text-xs font-bold transition-colors disabled:opacity-50">
                                        Download CSV
                                    </button>
                                    <button onClick={handleCopy} className="px-5 py-2 bg-indigo-600 text-white hover:bg-indigo-700 rounded-lg text-xs font-bold shadow-md transition-colors flex items-center gap-2">
                                        <span>Copy Data</span>
                                        <span className="bg-white/20 px-1.5 rounded text-[9px]">Sanitized</span>
                                    </button>
                                </div>
                            </div>

                            {/* Data Table */}
                            <div className="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden flex flex-col h-[600px] relative">
                                {/* Table Header Status */}
                                <div className="bg-slate-50 border-b border-slate-200 px-4 py-2 flex justify-between items-center">
                                    <div className="text-[10px] font-black text-slate-400 uppercase tracking-widest">
                                        {processedBatches.length > 0 ? 'Audit Results' : 'Preview / Raw Data'}
                                    </div>
                                    {isProcessing && (
                                        <div className="flex items-center gap-3">
                                            <div className="w-32 h-1.5 bg-slate-200 rounded-full overflow-hidden">
                                                <div className="h-full bg-blue-500 transition-all duration-300" style={{ width: `${progress.percent}%` }}></div>
                                            </div>
                                            <span className="text-[10px] font-bold text-blue-600">{progress.percent}%</span>
                                        </div>
                                    )}
                                </div>

                                <div className="flex-1 overflow-auto bg-white scrollbar-thin">
                                    <table className="w-full text-[11px] border-collapse min-w-[1000px]">
                                        <thead className="bg-slate-50 sticky top-0 z-10 shadow-sm">
                                            <tr>
                                                {displayHeaders.map(h => (
                                                    <th key={h} className="p-3 text-left font-bold text-slate-600 border-r border-slate-200 last:border-0 whitespace-nowrap bg-slate-50">
                                                        {h}
                                                    </th>
                                                ))}
                                            </tr>
                                        </thead>
                                        <tbody className="divide-y divide-slate-100">
                                            {processedBatches.length === 0 ? (
                                                rawRows.length === 0 ? (
                                                    <tr>
                                                        <td colSpan={displayHeaders.length} className="p-20 text-center text-slate-300 font-bold uppercase tracking-widest">
                                                            No Data Loaded
                                                        </td>
                                                    </tr>
                                                ) : (
                                                    rawRows.map((row, i) => (
                                                        <tr key={i} className="hover:bg-slate-50 transition-colors">
                                                            {displayHeaders.map(h => (
                                                                <td key={h} className="p-2 border-r border-slate-100 text-slate-600 whitespace-nowrap overflow-hidden text-ellipsis max-w-[200px]">
                                                                    {row[h]}
                                                                </td>
                                                            ))}
                                                        </tr>
                                                    ))
                                                )
                                            ) : (
                                                processedBatches.map((batch, bIdx) => (
                                                    <React.Fragment key={bIdx}>
                                                        {/* Brand Header */}
                                                        <tr className="bg-slate-100 border-y border-slate-200">
                                                            <td colSpan={displayHeaders.length} className="px-4 py-1.5 font-black text-slate-600 text-[10px] uppercase tracking-wider flex items-center gap-2">
                                                                <span className="w-2 h-2 bg-blue-500 rounded-full"></span>
                                                                {batch.brand}
                                                                {batch.grounding?.length > 0 && (
                                                                    <span className="ml-auto text-[9px] font-normal text-slate-400">
                                                                        Sources: {batch.grounding.length}
                                                                    </span>
                                                                )}
                                                            </td>
                                                        </tr>
                                                        {/* Corrected Rows */}
                                                        {batch.corrected.map((row, rIdx) => (
                                                            <tr key={`c-${bIdx}-${rIdx}`} className="hover:bg-slate-50 group">
                                                                {displayHeaders.map(h => {
                                                                    const origVal = String(batch.original[rIdx]?.[h] || "").trim();
                                                                    const newVal = String(row[h] || "").trim();
                                                                    const isDiff = origVal !== newVal && h !== UPDATE_DATE_COL;
                                                                    return (
                                                                        <td key={h} className={`p-2 border-r border-slate-100 whitespace-nowrap ${isDiff ? 'bg-red-50 text-red-700 font-bold border-red-100' : 'text-slate-600'}`}>
                                                                            {row[h]}
                                                                        </td>
                                                                    );
                                                                })}
                                                            </tr>
                                                        ))}
                                                        {/* New Items */}
                                                        {batch.newItems.map((row, nIdx) => (
                                                            <tr key={`n-${bIdx}-${nIdx}`} className="bg-blue-50/40 hover:bg-blue-50">
                                                                {displayHeaders.map(h => (
                                                                    <td key={h} className="p-2 border-r border-slate-100/50 text-blue-700 font-bold whitespace-nowrap">
                                                                        {row[h]}
                                                                    </td>
                                                                ))}
                                                            </tr>
                                                        ))}
                                                    </React.Fragment>
                                                ))
                                            )}
                                        </tbody>
                                    </table>
                                </div>
                            </div>

                            {/* Log Viewer Panel */}
                            {logViewer.isOpen && logHistory.length > 0 && (
                                <div className="bg-slate-900 rounded-xl p-0 overflow-hidden shadow-2xl animate-fade-in border border-slate-800">
                                    <div className="bg-slate-800 px-4 py-3 flex justify-between items-center border-b border-slate-700">
                                        <div className="flex items-center gap-4">
                                            <h3 className="text-blue-400 font-black text-xs uppercase tracking-widest">System Logs</h3>
                                            <div className="flex bg-slate-900 rounded-lg p-0.5">
                                                <button onClick={() => setLogViewer(p => ({ ...p, type: 'prompt' }))} className={`px-3 py-1 rounded-md text-[10px] font-bold transition-all ${logViewer.type === 'prompt' ? 'bg-blue-600 text-white' : 'text-slate-400 hover:text-white'}`}>Prompt</button>
                                                <button onClick={() => setLogViewer(p => ({ ...p, type: 'response' }))} className={`px-3 py-1 rounded-md text-[10px] font-bold transition-all ${logViewer.type === 'response' ? 'bg-emerald-600 text-white' : 'text-slate-400 hover:text-white'}`}>Response</button>
                                            </div>
                                            <select
                                                value={logViewer.index}
                                                onChange={e => setLogViewer(p => ({ ...p, index: Number(e.target.value) }))}
                                                className="bg-slate-900 border border-slate-700 text-slate-300 text-[10px] rounded px-2 py-1 outline-none focus:border-blue-500 max-w-[200px]"
                                            >
                                                {logHistory.map((l, i) => (
                                                    <option key={l.id} value={i}>{l.timestamp} - {l.brand} - {l.round}</option>
                                                ))}
                                            </select>
                                        </div>
                                        <button onClick={() => setLogViewer(p => ({ ...p, isOpen: false }))} className="text-slate-400 hover:text-white transition-colors">✕</button>
                                    </div>
                                    <div className="p-4 overflow-x-auto">
                                        <pre className="text-[10px] font-mono text-slate-300 whitespace-pre-wrap leading-relaxed max-h-[300px] scrollbar-thin">
                                            {logViewer.type === 'prompt'
                                                ? logHistory[logViewer.index]?.prompt
                                                : JSON.stringify(logHistory[logViewer.index]?.response, null, 2)
                                            }
                                        </pre>
                                    </div>
                                </div>
                            )}

                        </main>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>