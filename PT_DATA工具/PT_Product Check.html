<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PT Product Website Auditor (Gemini Search)</title>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f1f5f9;
            color: #0f172a;
        }

        .font-mono {
            font-family: 'JetBrains Mono', monospace;
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #e2e8f0;
        }

        ::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .animate-fade-in {
            animation: fadeIn 0.4s ease-out forwards;
        }

        .toast-enter {
            animation: slideInRight 0.3s ease-out forwards;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo } = React;

        // ==========================================
        // 1. CONFIGURATION
        // ==========================================
        const MODEL_ID = "gemini-2.5-flash-preview-09-2025";
        const PT_DATA_GS_URL = "https://script.google.com/macros/s/AKfycbxayHvvpWggMF8yEtYJxhYjoCe8kR65SxIQwQkHbc7S2XCRs-VxOXWzGEgKClG56vQfLA/exec";

        // Columns to DISPLAY in the table (simplified view)
        // Note: Latest price column (YYYYMMDD) is added dynamically
        const BASE_DISPLAY_COLS = ["Platform", "Model #", "Accessories", "Brand", "Title", "Product URL", "Exclude Update"];
        // Columns to HIDE from display but KEEP in data for Copy/Export
        const HIDDEN_COLS = ["Image URL", "SKU", "Date Created"];

        // FIXED column order for export        // Columns for Export (Results) - EXCLUDING Repeat check, Image, Price Tag
        const EXPORT_COLS_FIXED = [
            "Date Created", "Platform", "Model #", "Accessories", "Brand",
            "Title", "SKU", "Product URL", "Image URL", "Exclude Update",
            "Audit Status", "Audit Reason"
        ];

        const CHUNK_SIZE = 10;
        const MAX_RETRIES = 3;
        const BASE_DELAY_MS = 2000;

        // Simplified accessory categories
        const ACCESSORY_KEYS = ["Blade", "Stand", "Battery", "CP"];

        // GS API Password (not public)
        const GS_API_KEY = "55759180";

        // ==========================================
        // 2. HELPERS
        // ==========================================
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        const sanitizeForExport = (val) => (val === null || val === undefined) ? "" : String(val).replace(/[\n\r\t]/g, " ").trim();

        // ==========================================
        // 3. GEMINI SERVICE (with Google Search)
        // ==========================================
        const Gemini_Service = {
            callAPI: async (dataChunk, apiKey) => {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_ID}:generateContent?key=${apiKey}`;

                const systemInstruction = `*** SYSTEM COMMAND: PRODUCT ACCESSORY CHECKER ***
You are a Power Tool Accessory Auditor. Visit product pages and extract accessory information.

For each product, visit the Product URL and check:
1. **Page Validity**: Is this the correct product page for the given Brand + Model #?
2. **Model Extraction**: Identify the CORE model number (e.g., "GCM 8 SJL" NOT "GCM 8 SJL Set"). Ignore suffixes like "Set", "Plus", "Kit", "Bundle" unless they are part of the actual model ID (e.g., "Plus" in "V20 Plus").
3. **Accessories**: Find "Lieferumfang" / "Scope of Delivery" / "Includes" section.

CATEGORIZE accessories into ONLY these types:
- **Blade**: Sägeblatt, saw blade, cutting blade (count: x1, x2, etc.)
- **Stand**: Maschinenständer, Untergestell, machine stand, workstand. THIS IS A NORMAL ACCESSORY, NOT A BUNDLE.
- **Battery**: Akku, battery, Ladegerät, charger. If "ohne Akku" = write "without Battery"
- **Bundle**: ONLY if the product is bundled with a COMPLETELY DIFFERENT product category (e.g., Saw + Vacuum, Saw + Refrigerator, Saw + other unrelated tool). Stand is NOT a bundle!

IMPORTANT RULES:
- Stand (Maschinenständer) = accessory → write "Stand x1"
- Bundle = cross-category product combo → write "Bundle" only if truly bundled with unrelated products
- Most products should NOT have "Bundle" - only use it for real cross-category bundles

===== OUTPUT FORMAT (STRICT JSON SCHEMA) =====
Return a JSON ARRAY where each object contains EXACTLY these fields:
{
  "Brand": "string - Brand name from product page",
  "Model #": "string - Model number from product page",
  "Accessories": "string - 'with Blade x1, Stand x1' or '-' if none",
  "Audit Status": "string - 'OK' | 'Mismatch' | 'Invalid URL'",
  "Audit Reason": "string - '-' if OK, otherwise brief explanation"
}

===== EXAMPLES =====
[
  {"Brand": "Bosch", "Model #": "GCM 12 GDL", "Accessories": "with Blade x1, Stand x1", "Audit Status": "OK", "Audit Reason": "-"},
  {"Brand": "Einhell", "Model #": "TC-MS 216", "Accessories": "-", "Audit Status": "Mismatch", "Audit Reason": "Page shows model ABC-111"}
]

===== CRITICAL JSON RULES =====
1. Output MUST be a valid JSON array starting with '[' and ending with ']'
2. Use double quotes for ALL strings (not single quotes)
3. NO trailing commas after the last item
4. NO comments or explanations outside the JSON
5. Return EXACTLY the same number of objects as input products
6. All text must be in ENGLISH

Output ONLY valid JSON. Start with '['.`;

                const execute = async (retryCount = 0) => {
                    try {
                        const payload = {
                            contents: [{ parts: [{ text: `Audit these products:\n${JSON.stringify(dataChunk)}` }] }],
                            systemInstruction: { parts: [{ text: systemInstruction }] },
                            tools: [{ "google_search": {} }]
                        };
                        const response = await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(payload) });
                        if (!response.ok) {
                            if (response.status === 429) throw new Error("Rate Limit");
                            throw new Error(`HTTP ${response.status}`);
                        }
                        const resJson = await response.json();
                        const text = resJson.candidates?.[0]?.content?.parts?.[0]?.text || "";

                        // --- Robust JSON Extraction & Repair Logic ---
                        let jsonStr = text.trim();

                        // 1. Find the widest possible JSON container (Array [] preferred)
                        const firstOpen = jsonStr.search(/[\[\{]/);
                        const lastCloseArr = jsonStr.lastIndexOf(']');
                        const lastCloseObj = jsonStr.lastIndexOf('}');
                        const lastClose = Math.max(lastCloseArr, lastCloseObj);

                        if (firstOpen === -1 || lastClose === -1) {
                            console.warn("No JSON structure found:", text.substring(0, 100));
                            throw new Error("No JSON Structure Found");
                        }

                        jsonStr = jsonStr.substring(firstOpen, lastClose + 1);

                        let parsedData;
                        try {
                            parsedData = JSON.parse(jsonStr);
                        } catch (parseError) {
                            let recovered = false;

                            // Strategy A: Trim trailing garbage (}}, ]], etc.)
                            if (!recovered) {
                                let tempStr = jsonStr;
                                for (let i = 0; i < 5; i++) {
                                    if (tempStr.endsWith('}') || tempStr.endsWith(']')) {
                                        tempStr = tempStr.substring(0, tempStr.length - 1).trim();
                                        try {
                                            parsedData = JSON.parse(tempStr);
                                            recovered = true;
                                            console.warn("JSON Repaired by trimming trailing characters");
                                            break;
                                        } catch (e) { continue; }
                                    } else break;
                                }
                            }

                            // Strategy B: Add missing closing bracket
                            if (!recovered && jsonStr.startsWith('[') && !jsonStr.endsWith(']')) {
                                try {
                                    parsedData = JSON.parse(jsonStr + ']');
                                    recovered = true;
                                    console.warn("JSON Repaired by adding missing ]");
                                } catch (e) { }
                            }

                            // Strategy C: Regex extract individual objects
                            if (!recovered) {
                                const objectMatches = jsonStr.match(/\{[^{}]*\}/g);
                                if (objectMatches && objectMatches.length > 0) {
                                    try {
                                        parsedData = objectMatches.map(m => JSON.parse(m));
                                        recovered = true;
                                        console.warn("JSON Repaired by extracting individual objects");
                                    } catch (e) { }
                                }
                            }

                            if (!recovered) {
                                console.error("JSON Parse Failed, Raw:", text);
                                throw new Error("Invalid JSON Output from AI");
                            }
                        }

                        // Ensure it's an array
                        if (!Array.isArray(parsedData)) {
                            if (parsedData.corrected) parsedData = parsedData.corrected;
                            else parsedData = [parsedData];
                        }

                        return parsedData;

                    } catch (error) {
                        if (retryCount < MAX_RETRIES) {
                            const delay = Math.pow(2, retryCount) * BASE_DELAY_MS;
                            console.warn(`Retry ${retryCount + 1}/${MAX_RETRIES} after ${delay}ms...`);
                            await sleep(delay);
                            return execute(retryCount + 1);
                        }
                        throw error;
                    }
                };
                return execute();
            }
        };

        // ==========================================
        // 4. MAIN APP COMPONENT
        // ==========================================
        const App = () => {
            const [apiKey, setApiKey] = useState(localStorage.getItem('AUDITOR_API_KEY') || '');
            const [gsUrl, setGsUrl] = useState(PT_DATA_GS_URL);
            const [ptDataSheets, setPtDataSheets] = useState([]);
            const [selectedSheet, setSelectedSheet] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [rawRows, setRawRows] = useState([]);
            const [fullHeadersOrder, setFullHeadersOrder] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [progress, setProgress] = useState({ percent: 0, status: "" });
            const [processedBatches, setProcessedBatches] = useState([]);
            const [toast, setToast] = useState(null);
            const [logHistory, setLogHistory] = useState([]);
            const [logViewer, setLogViewer] = useState({ isOpen: false, index: 0 });
            const [onlyEmptyAccessories, setOnlyEmptyAccessories] = useState(true); // Default checked

            // Validation Lists from Check sheet
            const [validBrands, setValidBrands] = useState([]);
            const [validModels, setValidModels] = useState([]);
            const [validationMode, setValidationMode] = useState('MTS'); // MTS or TBS

            useEffect(() => { if (apiKey) localStorage.setItem('AUDITOR_API_KEY', apiKey); }, [apiKey]);

            const showToast = (message, type = 'success') => { setToast({ message, type }); setTimeout(() => setToast(null), 4000); };

            // Display Headers = BASE_DISPLAY_COLS + Latest Price + Audit columns
            const displayHeaders = useMemo(() => {
                if (fullHeadersOrder.length === 0) return [];
                // Find latest date column (YYYYMMDD format)
                const dateColumns = fullHeadersOrder.filter(h => /^\d{8}$/.test(h)).sort().reverse();
                const latestPrice = dateColumns[0] || null;
                // Build display list
                const cols = BASE_DISPLAY_COLS.filter(c => fullHeadersOrder.includes(c));
                if (latestPrice && !cols.includes(latestPrice)) cols.push(latestPrice);
                // Add Audit columns
                if (fullHeadersOrder.includes("Audit Status")) cols.push("Audit Status");
                if (fullHeadersOrder.includes("Audit Reason")) cols.push("Audit Reason");
                return cols;
            }, [fullHeadersOrder]);

            // Connect to GS
            const handleConnect = async () => {
                setIsLoading(true);
                try {
                    const res = await fetch(`${gsUrl}?action=getSheets&key=${GS_API_KEY}`);
                    const sheets = await res.json();
                    if (sheets.error) throw new Error(sheets.hint ? `${sheets.error} (Hint: ${sheets.hint})` : sheets.error);
                    if (Array.isArray(sheets)) {
                        const dataSheets = sheets.filter(s => s.startsWith('Data_'));
                        setPtDataSheets(dataSheets);
                        showToast(`Connected! ${dataSheets.length} Data sheets found.`);
                    }
                } catch (e) { showToast("Connection failed: " + e.message, "error"); }
                setIsLoading(false);
            };

            // Load Sheet Data + Check sheet for validation
            const handleLoadSheet = async (sheetName) => {
                if (!sheetName) return;
                setSelectedSheet(sheetName);
                setIsLoading(true);
                setProcessedBatches([]);

                // Auto-detect validation mode from sheet name
                const mode = sheetName.toUpperCase().includes('TBS') ? 'TBS' : 'MTS';
                setValidationMode(mode);

                try {
                    // Load main data
                    const res = await fetch(`${gsUrl}?action=getData&sheet=${encodeURIComponent(sheetName)}&key=${GS_API_KEY}`);
                    const rows = await res.json();
                    if (rows.error) throw new Error(rows.hint ? `${rows.error} (Hint: ${rows.hint})` : rows.error);
                    if (!Array.isArray(rows)) throw new Error("Invalid data");

                    // Preserve FULL header order from first row (DO NOT add extra columns)
                    const headers = rows.length > 0 ? Object.keys(rows[0]) : [];

                    setFullHeadersOrder(headers);
                    setRawRows(rows);

                    // Load Check sheet for validation lists
                    try {
                        const checkRes = await fetch(`${gsUrl}?action=getData&sheet=Check&key=${GS_API_KEY}`);
                        const checkRows = await checkRes.json();
                        if (Array.isArray(checkRows) && checkRows.length > 0) {
                            // Extract Brand list (first column)
                            const brands = checkRows.map(r => r['Brand']).filter(b => b && b.trim());
                            setValidBrands(brands);

                            // Extract Model list based on mode (MTS or TBS column)
                            const modelCol = mode === 'TBS' ? 'TBS' : 'MTS';
                            // Also check for CMTS/CTBS variants
                            const models = checkRows.map(r => r[modelCol] || r[`C${modelCol}`]).filter(m => m && m.trim());
                            setValidModels(models);

                            console.log(`Validation loaded: ${brands.length} brands, ${models.length} models (${mode})`);
                        }
                    } catch (checkErr) {
                        console.warn('Check sheet not found or error:', checkErr);
                    }

                    showToast(`Loaded ${rows.length} rows. Mode: ${mode}`);
                } catch (err) { showToast("Load failed: " + err.message, "error"); }
                setIsLoading(false);
            };

            // --- MAIN AUDIT (Parallel Processing with Retry Loop) ---
            const PARALLEL_BATCHES = 4; // Process 4 batches concurrently

            const startAudit = async () => {
                if (isProcessing || rawRows.length === 0 || !apiKey) { showToast(!apiKey ? "API Key missing" : "No data", "error"); return; }
                setIsProcessing(true);
                setProcessedBatches([]);
                setLogHistory([]);
                setProgress({ percent: 0, status: "Starting..." });

                // Filter rows & Keep Original Index
                const initialCount = rawRows.length;
                let rowsToProcess = rawRows.map((r, i) => ({ ...r, _originalIndex: i }))
                    .filter(r => (r['Exclude Update'] || '').toUpperCase() !== 'Y');
                if (onlyEmptyAccessories) {
                    // Process rows with empty Brand OR empty Model # OR empty Accessories
                    rowsToProcess = rowsToProcess.filter(r =>
                        !r['Brand'] || r['Brand'].trim() === '' ||
                        !r['Model #'] || r['Model #'].trim() === '' ||
                        !r['Accessories'] || r['Accessories'].trim() === '' || r['Accessories'] === '-'
                    );
                }

                if (rowsToProcess.length === 0) {
                    showToast("All rows are excluded", "error");
                    setIsProcessing(false);
                    return;
                }

                // Build all batches
                const allBatches = [];
                for (let i = 0; i < rowsToProcess.length; i += CHUNK_SIZE) {
                    allBatches.push({
                        batchId: allBatches.length + 1,
                        rows: rowsToProcess.slice(i, i + CHUNK_SIZE),
                        status: 'pending',
                        results: null,
                        retryCount: 0
                    });
                }

                const totalBatches = allBatches.length;
                let completedCount = 0;
                const maxRetryRounds = 5;
                let retryRound = 0;

                // Process a single batch
                const processBatch = async (batch) => {
                    const chunkForAI = batch.rows.map(r => ({
                        "Brand": r.Brand || "",
                        "Model #": r['Model #'] || "",
                        "Title": r.Title || "",
                        "Product URL": r['Product URL'] || ""
                    }));

                    try {
                        const aiResults = await Gemini_Service.callAPI(chunkForAI, apiKey);
                        setLogHistory(prev => [{ id: Date.now(), batch: batch.batchId, response: aiResults }, ...prev]);
                        batch.results = aiResults;
                        batch.status = 'success';
                        return true;
                    } catch (e) {
                        console.error(`Batch ${batch.batchId} failed:`, e);
                        setLogHistory(prev => [{ id: Date.now(), batch: batch.batchId, error: e.message, retry: batch.retryCount }, ...prev]);
                        batch.status = 'failed';
                        batch.retryCount++;
                        return false;
                    }
                };

                // Validation helper
                const validateAndMerge = (origRow, match) => {
                    const newRow = { ...origRow };
                    if (match) {
                        if ((!newRow['Brand'] || newRow['Brand'].trim() === '') && match['Brand']) newRow['Brand'] = match['Brand'];
                        if ((!newRow['Model #'] || newRow['Model #'].trim() === '') && match['Model #']) newRow['Model #'] = match['Model #'];
                        if ((!newRow['Accessories'] || newRow['Accessories'].trim() === '' || newRow['Accessories'] === '-') && match['Accessories']) newRow['Accessories'] = match['Accessories'];
                        if (match["Audit Status"]) newRow["Audit Status"] = match["Audit Status"];
                        if (match["Audit Reason"]) newRow["Audit Reason"] = match["Audit Reason"];
                    }
                    // Validate Brand - ALWAYS use exact value from Check sheet
                    const brandValue = (newRow['Brand'] || '').trim();
                    if (brandValue && validBrands.length > 0) {
                        // First try exact match (case-insensitive)
                        const exactMatch = validBrands.find(b => b.toLowerCase() === brandValue.toLowerCase());
                        if (exactMatch) {
                            // Use the EXACT value from Check sheet (correct case/spacing)
                            if (newRow['Brand'] !== exactMatch) {
                                newRow['Brand'] = exactMatch;
                                newRow['_brandCorrected'] = true;
                            }
                        } else {
                            // Try fuzzy match (contains)
                            const fuzzyMatch = validBrands.find(b =>
                                b.toLowerCase().includes(brandValue.toLowerCase()) ||
                                brandValue.toLowerCase().includes(b.toLowerCase())
                            );
                            if (fuzzyMatch) {
                                newRow['Brand'] = fuzzyMatch;
                                newRow['_brandCorrected'] = true;
                            } else {
                                newRow['_brandInvalid'] = true;
                            }
                        }
                    }
                    // Validate Model # - ALWAYS use exact value from Check sheet
                    const modelValue = (newRow['Model #'] || '').trim();
                    if (modelValue && validModels.length > 0) {
                        // Normalize: remove spaces and hyphens for comparison
                        const normalize = (s) => s.toLowerCase().replace(/[\s\-]/g, '');

                        // 1. Exact match
                        let match = validModels.find(m => m.toLowerCase() === modelValue.toLowerCase());

                        // 2. Normalized match (ignore spaces/hyphens)
                        if (!match) {
                            match = validModels.find(m => normalize(m) === normalize(modelValue));
                        }

                        // 3. Fuzzy match check (e.g. "GCM 8 SJL Set" contains "GCM 8 SJL")
                        // Sort by length DESC to match longest prefix/substring first
                        if (!match) {
                            const sortedModels = [...validModels].sort((a, b) => b.length - a.length);
                            match = sortedModels.find(m => {
                                const normM = normalize(m);
                                const normVal = normalize(modelValue);
                                return normVal.includes(normM);
                            });
                        }

                        if (match) {
                            if (newRow['Model #'] !== match) {
                                newRow['Model #'] = match;
                                newRow['_modelCorrected'] = true;
                            }
                        } else {
                            newRow['_modelInvalid'] = true;
                        }
                    }
                    return newRow;
                };

                try {
                    // Main loop with retry
                    while (retryRound <= maxRetryRounds) {
                        const pendingBatches = allBatches.filter(b => b.status === 'pending' || b.status === 'failed');
                        if (pendingBatches.length === 0) break;

                        const roundLabel = retryRound === 0 ? 'Processing' : `Retry ${retryRound}`;

                        // Process in parallel groups
                        for (let i = 0; i < pendingBatches.length; i += PARALLEL_BATCHES) {
                            const group = pendingBatches.slice(i, i + PARALLEL_BATCHES);
                            setProgress({ percent: Math.round((completedCount / totalBatches) * 100), status: `${roundLabel}: ${group.map(b => b.batchId).join(',')}...` });

                            const results = await Promise.allSettled(group.map(b => processBatch(b)));
                            completedCount += results.filter(r => r.value === true).length;

                            await sleep(300);
                        }
                        retryRound++;
                    }

                    // Update RAW ROWS directly with results (AI Processed Rows)
                    let newRawRows = [...rawRows];

                    // 1. Merge AI Results
                    allBatches.filter(b => b.status === 'success').forEach(batch => {
                        batch.rows.forEach((origRow, idx) => {
                            const match = batch.results && batch.results[idx] ? batch.results[idx] : null;
                            const updatedRow = validateAndMerge(origRow, match);

                            // Update by Index
                            if (updatedRow._originalIndex !== undefined) {
                                newRawRows[updatedRow._originalIndex] = { ...updatedRow };
                            }
                        });
                    });

                    // 2. Global Validation Pass (Run on ALL rows to Case-Correct/Normalize everything)
                    // This ensures rows that were SKIPPED by AI still get Brand/Model normalization
                    newRawRows = newRawRows.map(row => validateAndMerge(row, null));

                    setRawRows(newRawRows);
                    // setProcessedBatches is less important now as we use rawRows directly, but keep for consistency if needed?
                    // Actually processedBatches was used for old logic. We can clear it or just ignore.

                    const failedCount = allBatches.filter(b => b.status === 'failed').length;
                    setProgress({ percent: 100, status: `Done! ${completedCount}/${totalBatches} batches processed. Global validation applied.` });
                    showToast(`Audit finished! Validation applied to ${newRawRows.length} rows.`);
                } catch (error) {
                    showToast("Audit Error: " + error.message, "error");
                } finally {
                    setIsProcessing(false);
                }
            };

            // --- Build export headers: Fixed columns + date columns (sorted newest first) ---
            const getExportHeaders = () => {
                const dateColumns = fullHeadersOrder.filter(h => /^\d{8}$/.test(h)).sort().reverse();
                return [...EXPORT_COLS_FIXED, ...dateColumns];
            };

            // --- COPY (FULL DATA including excluded rows) ---
            const handleCopy = () => {
                if (rawRows.length === 0) return showToast("No data", "error");
                // Use FIXED export order
                const exportHeaders = getExportHeaders();
                let tsv = exportHeaders.join('\t') + '\n';
                rawRows.forEach(row => { tsv += exportHeaders.map(h => sanitizeForExport(row[h])).join('\t') + '\n'; });
                navigator.clipboard.writeText(tsv).then(() => showToast(`Copied ${rawRows.length} rows (all columns)`)).catch(() => showToast("Copy failed", "error"));
            };

            // --- DOWNLOAD CSV (FULL DATA including excluded rows) ---
            const handleDownloadCSV = () => {
                if (rawRows.length === 0) return showToast("No data", "error");
                // Use FIXED export order
                const exportHeaders = getExportHeaders();
                let csv = '\ufeff' + exportHeaders.map(h => `"${h}"`).join(',') + '\n';
                rawRows.forEach(row => {
                    csv += exportHeaders.map(h => {
                        const val = sanitizeForExport(row[h]);
                        return `"${String(val).replace(/"/g, '""')}"`; // Escape quotes
                    }).join(',') + '\n';
                });

                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement("a");
                link.setAttribute("href", url);
                link.setAttribute("download", `Audit_${new Date().toISOString().slice(0, 10)}.csv`);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };

            // ==========================================
            // 5. RENDER (MATCHING VALIDATOR UI)
            // ==========================================
            return (
                <div className="min-h-screen pb-20">
                    {toast && (
                        <div className={`fixed top-5 left-1/2 transform -translate-x-1/2 z-50 px-6 py-3 rounded-full shadow-2xl font-bold text-white text-sm toast-enter ${toast.type === 'error' ? 'bg-red-500' : 'bg-emerald-600'}`}>
                            {toast.type === 'error' ? '⚠️' : '✅'} {toast.message}
                        </div>
                    )}

                    {/* Header */}
                    <header className="bg-white border-b border-slate-200 sticky top-0 z-30 shadow-sm">
                        <div className="container mx-auto px-4 py-4 flex flex-col md:flex-row justify-between items-center gap-4">
                            <div className="flex items-center gap-3">
                                <div className="bg-indigo-600 text-white p-2 rounded-lg font-black text-xl tracking-tighter">PT</div>
                                <div>
                                    <h1 className="text-xl font-bold text-slate-800 tracking-tight">Product Website Auditor <span className="text-xs bg-slate-100 text-slate-500 px-2 py-0.5 rounded-full border border-slate-200">GEMINI SEARCH</span></h1>
                                    <p className="text-[10px] text-slate-400 font-bold uppercase tracking-widest mt-0.5">Consistency & Accessories Check v1.0</p>
                                </div>
                            </div>
                        </div>
                    </header>

                    <div className="container mx-auto px-4 py-6 grid grid-cols-1 lg:grid-cols-12 gap-6">

                        {/* Sidebar */}
                        <aside className="lg:col-span-3 space-y-6">
                            {/* Panel 1: Data Source */}
                            <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-5 space-y-4 animate-fade-in">
                                <h3 className="text-xs font-black text-slate-400 uppercase tracking-widest border-b border-slate-100 pb-2">PT Data 平台</h3>
                                <button onClick={handleConnect} disabled={isLoading || ptDataSheets.length > 0}
                                    className={`w-full py-2 rounded-lg text-xs font-bold transition-all shadow-sm ${ptDataSheets.length > 0 ? 'bg-emerald-50 text-emerald-600 border border-emerald-200' : 'bg-violet-600 text-white hover:bg-violet-700'}`}>
                                    {isLoading ? '...' : ptDataSheets.length > 0 ? `✓ CONNECTED (${ptDataSheets.length} sheets)` : 'CONNECT PT DATA'}
                                </button>
                                <div className="space-y-1">
                                    <label className="text-[10px] font-bold text-slate-500 uppercase">Select Sheet</label>
                                    <select value={selectedSheet} onChange={e => handleLoadSheet(e.target.value)} disabled={ptDataSheets.length === 0}
                                        className="w-full bg-violet-50 border border-violet-200 text-violet-700 text-sm rounded-lg p-2.5 outline-none focus:ring-2 focus:ring-violet-500 disabled:opacity-50 font-medium">
                                        <option value="">{ptDataSheets.length > 0 ? "Select sheet..." : "Connect first..."}</option>
                                        {ptDataSheets.map(n => <option key={n} value={n}>{n.replace('Data_', 'PT Data - ')}</option>)}
                                    </select>
                                </div>
                            </div>

                            {/* Panel 2: Config */}
                            <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-5 space-y-4 animate-fade-in" style={{ animationDelay: '0.1s' }}>
                                <h3 className="text-xs font-black text-slate-400 uppercase tracking-widest border-b border-slate-100 pb-2">Configuration</h3>
                                <div className="space-y-1">
                                    <label className="text-[10px] font-bold text-slate-500 uppercase">Gemini API Key</label>
                                    <input type="password" value={apiKey} onChange={e => setApiKey(e.target.value)} placeholder="Enter Key..."
                                        className="w-full bg-slate-50 border border-slate-200 text-slate-600 text-xs rounded-lg p-2 font-mono" />
                                </div>
                                <label className="flex items-center gap-2 cursor-pointer">
                                    <input type="checkbox" checked={onlyEmptyAccessories} onChange={e => setOnlyEmptyAccessories(e.target.checked)}
                                        className="w-4 h-4 text-violet-600 bg-slate-100 border-slate-300 rounded focus:ring-violet-500" />
                                    <span className="text-xs text-slate-600 font-medium">Process Missing Info (Brand/Model/Acc)</span>
                                </label>
                            </div>

                            {/* Action Button */}
                            <button onClick={startAudit} disabled={isProcessing || !selectedSheet}
                                className={`w-full py-4 rounded-xl shadow-lg font-black text-sm tracking-wide transition-all transform hover:scale-[1.02] active:scale-[0.98] ${isProcessing ? 'bg-slate-100 text-slate-400 cursor-not-allowed' : 'bg-gradient-to-r from-indigo-600 to-purple-600 text-white hover:shadow-indigo-200'}`}>
                                {isProcessing ? (
                                    <div className="flex flex-col items-center gap-1">
                                        <div className="w-4 h-4 border-2 border-slate-300 border-t-indigo-500 rounded-full animate-spin"></div>
                                        <span className="text-[10px] font-mono">{progress.status}</span>
                                    </div>
                                ) : <span className="flex items-center justify-center gap-2">START AUDIT PROCESS <span>➔</span></span>}
                            </button>
                        </aside>

                        {/* Main Content */}
                        <main className="lg:col-span-9 space-y-6">
                            {/* Toolbar */}
                            <div className="bg-white rounded-xl p-2 border border-slate-200 shadow-sm flex flex-wrap gap-2 items-center justify-between">
                                <div className="flex gap-2">
                                    <button onClick={() => setLogViewer(p => ({ ...p, isOpen: !p.isOpen }))} className="px-4 py-2 bg-slate-100 hover:bg-slate-200 text-slate-600 rounded-lg text-xs font-bold transition-colors">
                                        {logViewer.isOpen ? 'Hide Logs' : 'Show Logs'}
                                    </button>
                                </div>
                                <div className="flex gap-2">
                                    <button onClick={handleDownloadCSV} disabled={rawRows.length === 0} className="px-4 py-2 bg-purple-50 text-purple-600 border border-purple-100 hover:bg-purple-100 rounded-lg text-xs font-bold transition-colors disabled:opacity-50">Download CSV</button>
                                    <button onClick={handleCopy} className="px-5 py-2 bg-indigo-600 text-white hover:bg-indigo-700 rounded-lg text-xs font-bold shadow-md transition-colors flex items-center gap-2">
                                        <span>Copy Data</span><span className="bg-white/20 px-1.5 rounded text-[9px]">Full</span>
                                    </button>
                                </div>
                            </div>

                            {/* Data Table */}
                            <div className="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden flex flex-col h-[600px] relative">
                                <div className="bg-slate-50 border-b border-slate-200 px-4 py-2 flex justify-between items-center">
                                    <div className="text-[10px] font-black text-slate-400 uppercase tracking-widest">{processedBatches.length > 0 ? 'Audit Results' : 'Preview / Raw Data'}</div>
                                    {isProcessing && (
                                        <div className="flex items-center gap-3">
                                            <div className="w-32 h-1.5 bg-slate-200 rounded-full overflow-hidden"><div className="h-full bg-indigo-500 transition-all duration-300" style={{ width: `${progress.percent}%` }}></div></div>
                                            <span className="text-[10px] font-bold text-indigo-600">{progress.percent}%</span>
                                        </div>
                                    )}
                                </div>

                                <div className="flex-1 overflow-auto bg-white scrollbar-thin">
                                    <table className="w-full text-[11px] border-collapse min-w-[1000px]">
                                        <thead className="bg-slate-50 sticky top-0 z-10 shadow-sm">
                                            <tr>
                                                {displayHeaders.map(h => (
                                                    <th key={h} className="p-3 text-left font-bold text-slate-600 border-r border-slate-200 last:border-0 whitespace-nowrap bg-slate-50">{h}</th>
                                                ))}
                                            </tr>
                                        </thead>
                                        <tbody className="divide-y divide-slate-100">
                                            {(processedBatches.length > 0 ? processedBatches.flatMap(b => b.corrected) : rawRows).length === 0 ? (
                                                <tr><td colSpan={displayHeaders.length} className="p-20 text-center text-slate-300 font-bold uppercase tracking-widest">No Data Loaded</td></tr>
                                            ) : (
                                                (processedBatches.length > 0 ? processedBatches.flatMap(b => b.corrected) : rawRows).map((row, i) => {
                                                    const status = row["Audit Status"];
                                                    return (
                                                        <tr key={i} className="hover:bg-slate-50 transition-colors">
                                                            {displayHeaders.map(h => {
                                                                let cellClass = "p-2 border-r border-slate-100 text-slate-600 whitespace-nowrap overflow-hidden text-ellipsis max-w-[200px]";
                                                                let cellStyle = {};

                                                                // Audit Status coloring
                                                                if (h === "Audit Status") {
                                                                    if (status === "OK") cellClass += " bg-emerald-50 text-emerald-700 font-bold";
                                                                    else if (status === "Mismatch") cellClass += " bg-red-50 text-red-700 font-bold";
                                                                    else if (status === "Invalid URL") cellClass += " bg-amber-50 text-amber-700 font-bold";
                                                                }

                                                                // Brand validation coloring
                                                                if (h === "Brand" && (row['_brandCorrected'] || row['_brandInvalid'])) {
                                                                    cellClass += " font-bold";
                                                                    cellStyle = { color: '#dc2626', backgroundColor: '#fef2f2' }; // Red
                                                                }

                                                                // Model # validation coloring
                                                                if (h === "Model #" && (row['_modelCorrected'] || row['_modelInvalid'])) {
                                                                    cellClass += " font-bold";
                                                                    cellStyle = { color: '#dc2626', backgroundColor: '#fef2f2' }; // Red
                                                                }

                                                                return <td key={h} className={cellClass} style={cellStyle}>{row[h]}</td>;
                                                            })}
                                                        </tr>
                                                    );
                                                })
                                            )}
                                        </tbody>
                                    </table>
                                </div>
                            </div>

                            {/* Log Viewer Panel */}
                            {logViewer.isOpen && logHistory.length > 0 && (
                                <div className="bg-slate-900 rounded-xl p-0 overflow-hidden shadow-2xl animate-fade-in border border-slate-800">
                                    <div className="bg-slate-800 px-4 py-3 flex justify-between items-center border-b border-slate-700">
                                        <h3 className="text-indigo-400 font-black text-xs uppercase tracking-widest">System Logs ({logHistory.length})</h3>
                                        <button onClick={() => setLogViewer(p => ({ ...p, isOpen: false }))} className="text-slate-400 hover:text-white transition-colors">✕</button>
                                    </div>
                                    <div className="p-4 overflow-x-auto">
                                        <pre className="text-[10px] font-mono text-slate-300 whitespace-pre-wrap leading-relaxed max-h-[300px] scrollbar-thin">
                                            {JSON.stringify(logHistory, null, 2)}
                                        </pre>
                                    </div>
                                </div>
                            )}
                        </main>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>